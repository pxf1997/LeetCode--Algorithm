这题动态规划不能想当然 其中很多细节需要想明白:
正常的动态规划一般是dp[i]表示以nums[i]结尾的子数组 这里其实也可以用 每次用ans=max(ans, xxx)来处理最佳值(O(n^2)复杂度)

题解中使用的up[i]和down[i]表示数组nums[0...i]中的最长以上升趋势结尾和下降趋势作为结尾的子数列的长度
这样的话 可能带来一个问题 我TM不知道最后子序列是以什么结尾 凭啥你答案直接nums[i]和nums[i-1]作比较？
我们依次来分析
    1--nums[i-1]==nums[i] 等于是新加进来的nums[i]没有带来新信息 原来我们假如利用了nums[i-1]，
        那么现在两个数持平，既没法上升也没法下降;
        假如我们原来没有利用nums[i-1]那么同样nums[i]不会被用到
        故 up[i]=up[i-1], down[i]=down[i-1]
    2-- nums[i] > nums[i-1]

        我们考虑 up[i]可能的来源方式 只会跟up[i-1]和down[i-1]有关
        首先会不会up[i-1]之后再up了？ 不会 因为不可以两次重复up

        down[i-1]之后可能会跳跃到nums[i]上面 但是我们担心的一个点是 谁说down[i-1]对应子序列结尾的就是nums[i-1]?
        确实如此。 假设down[i-1]对应的元素叫a_k不是nums[i-1], a_k<nums[i]时候，我们同样可以让a_k跳跃到nums[i]上；
        假设a_k>=nums[i-1], 我们可以做交换把a_k换成nums[i-1]因为这样同样满足条件=>
        总之可以跳跃到nums[i]上 => up[i]=max(up[i-1], down[i-1]+1);


        我们考虑 down[i]可能的来源方式 只会跟up[i-1]和down[i-1]有关
        首先会不会down[i-1]之后再down了？ 不会 因为不可以两次重复down

        up[i-1]之后可能会下降道nums[i]上面 但是我们担心的一个点是
         谁说up[i-1]对应子序列结尾的就是nums[i-1]? 确实如此。
         假设up[i-1]对应的元素叫a_k不是nums[i-1], a_k>=nums[i]>nums[i-1]时候，我们可以让他下降到nums[i-1],
         这个最大值会被包括在down[i-1]里；a_k<nums[i]时候没法下降到nums[i-1] 不满足条件 =>down[i]=max(down[i-1], down[i-1]);

    3--nums[i] < nums[i-1] 这种情况和情况2是对称的 不做展开


贪心法
观察这个序列可以发现，我们不断地交错选择「峰」与「谷」，可以使得该序列尽可能长。
证明非常简单：如果我们选择了一个「过渡元素」，那么在原序列中，这个「过渡元素」的两侧有一个「峰」和一个「谷」。
不失一般性，我们假设在原序列中的出现顺序为「峰」「过渡元素」「谷」。300
如果「过渡元素」在选择的序列中小于其两侧的元素，那么「谷」一定没有在选择的序列中出现，
我们可以将「过渡元素」替换成「谷」；同理，如果「过渡元素」在选择的序列中大于其两侧的元素，
那么「峰」一定没有在选择的序列中出现，我们可以将「过渡元素」替换成「峰」。
这样一来，我们总可以将任意满足要求的序列中的所有「过渡元素」替换成「峰」或「谷」。
并且由于我们不断地交错选择「峰」与「谷」的方法就可以满足要求，因此这种选择方法就一定可以达到可选元素数量的最大值。

这样，我们只需要统计该序列中「峰」与「谷」的数量即可（注意序列两端的数也是「峰」或「谷」），但需要注意处理相邻的相同元素。

在实际代码中，我们记录当前序列的上升下降趋势。
每次加入一个新元素时，用新的上升下降趋势与之前对比，
如果出现了「峰」或「谷」，答案加一，并更新当前序列的上升下降趋势。
